# 스프링 핵심 원리 - 기본편

- **섹션 1. 객체 지향 설계와 스프링**
    - 스프링을 왜 만들었을까?
        
        자바 언어 기반의 프레임워크
        
        = 객체지향언어의 특성을 살려내는 프레임워크
        
    - 좋은 객체지향 프로그래밍
        - 객체지향 특징 : 추상화, 캡슐화, 상속, 다형
        - 컴포넌트를 쉽고 유연하게 변경하면서 개발하는 방법 → 다형성
        - 역할과 구현 → 클라이언트에 영향을 주지 않고(클라이언트는 인터페이스만 알면 됨, 내부 구조 몰라도 됨) 새로운 기능 제공 가능
        - 역할 = 인터페이스 / 구현 = 구현 클래스, 객체
        - 스프링은 다형성 극대화
        
    - 좋은 객체지향 설계의 5가지 원칙(SOLID)
        - SRP (Single responsibility principle) : 한 클래스는 하나의 책임만(변경)
        - OCP (Open/closed principle) : 확장에는 열려있으나, 변경에는 닫혀있게 → 다형성 활용 / 인터페이스 구현한 새로운 클래스 만들어서 새로운 기능 구현 (OCP는 지킬 수 없음ㅜㅜ → 스프링 컨테이너, DI 등 필요)
        - LSP (Liskov substitution principle / 리스코프 치환 원칙) : 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 됨
        - ISP (Interface segregation principle) : 특정 클라이언트를 위한 **인터페이스 여러개**가 **범용 인터페이스 하나**보다 **낫다**!
        - DIP (Dependency inversion principle / 의존관계 역전 원칙) : 인터페이스에 의존, 구현 클래스 의존 X
        - 다형성 만으로는 OCP, DIP 지킬 수 X

- **섹션 2. 스프링 핵심 원리 이해1 - 예제 만들기**
    
    회원 서비스: MemberServiceImpl
    
    - Map & HashMap
        - Map : 리스트나 배열처럼 순차적으로 해당 요소 값을 구하지 않고 key를 통해 value를 얻는다.
        - HashMap : Map 인터페이스를 상속하고 있기에 Map의 성질을 그대로 가지고 있고, Map은 키와 값으로 구성된 Entry객체를 저장하는 구조를 가지고 있는 자료구조이다.
            
            ![images_mon99745_post_fca77a41-14ea-4377-b734-afa098c5cb6d_image.png](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/images_mon99745_post_fca77a41-14ea-4377-b734-afa098c5cb6d_image.png)
            
    - soutv : System.out.println(“어쩌구 = “ + 어쩌구);
    - 주문 할인 도메인 설계
        
        ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled.png)
        

- **섹션 3. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용**
    - **ctrl + shift + T : Test 만들어주기!**
    - 문제점
        - 할인 정책을 변경 시 클라이언트인 OrderServiceImpl 코드 수정 필요 private final DiscountPolicy discountPolicy = new **RateDiscountPolicy();**
        - DIP 위반 : OrderServiceImpl는 추상 클래스 뿐 아니라 **구현 클래스도! 의존**
        
        ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%201.png)
        
        - OCP 위반 : OrderServiceImpl 코드를 변경하는 순간 위반
    - 해결방안
        - DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경 필요
        
        ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%202.png)
        
        - 누군가가 클라이언트인 OrderServiceImpl 에 DiscountPolicy 의 구현 객체를 대신 생성하고 주입해주어야 한다
        
    - **관심사의 분리!**
        
        ★AppConfig 등장★
        
        - 구현 객체를 생성하고 연결하는 책임을 가지는 별로의 클래스
        - **생성자 주입!**
        - 애플리케이션 실제 동작에 필요한 **구현 객체 생성**
        - public OrderService orderService(){
            
                return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy())
            
            }
            
            ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%203.png)
            
            ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%204.png)
            
        - DIP 완성!
    - AppConfig 리팩토링
        
        역할과 구현 한번에 볼 수 있게
        
        ex)
        
        public MemberService memberService(){
        
            return new MemberServiceImpl(*memberRepository*());
        
        }
        
        private static MemoryMemberRepository memberRepository() {
        
            return new MemoryMemberRepository();
        
        }
        
    - 구성 영역의 코드는 수정하되, 사용자 영역은 건들지 않고 개발 가능
    
    - IoC, DI, 컨테이너
        - 제어의 역전 IoC(Inversion of Control) : 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것
        - 의존관계 주입 DI (Dependency Injection) : 애플리케이션 실행 시점(런타임)에 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것 (동적인 객체 인스턴스 관계)
        - 의존관계 주입 사용시 이점
            1.  클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변
            경 가능
            2. 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경가
        - 의존관계 역전을 시켜주는 것 = “IoC 컨테이너” 또는 “DI 컨테이너”
    
    - 스프링으로 전환하기~
        
        @Configuration 이 붙으면 설정(구성)정보로 사용
        
        @Bean : 스프링 컨테이너에 등
        
        applicationContext.getBean(name : ”memberService”, MemberService.class); : name이랑 같은 이름의 메소드를 찾을거야! 타입은 MemberService!
        

- **섹션 4. 스프링 컨테이너와 스프링 빈**
    - 스프링 컨테이너 생성 과정
        
        ApplicationContext = 스프링 컨테이너 (인터페이스임!)
        
        ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%205.png)
        
        ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%206.png)
        
        ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%207.png)
        
    - 컨테이너 등록 빈 조회
        - *iter : 배열 for문 만들어줌
        - 스프링이 내부에서 사용하는 빈은 getRole() 로 구분 가능
        - ac.getBean(빈이름, 타입) : 스프링 컨테이너에서 빈 찾는 기본 방
    - 스프링 빈 조회 - 동일 타입이 둘 이상
        
        *static class : 클래스 안에 클래스 썼을 때 이 안에서만 쓸거다! 
        
    - 스프링 빈 조회 - 상속관계
        
        부모 타입으로 조회하면, 자식 타입도 함께 조회한다!
        

- **섹션 5. 싱글톤 컨테이너**
    - 웹 애플리케이션과 싱글톤
        
        여러명의 클라이언트가 동시에 서비스 요청 시 문제점 : 여러개의 객체가 생성 → 요청이 올 때마다 객체 생성 → 메모리 낭비 심함
        
        ****∴**** 해당 객체가 딱 1개 생성되고, 공유하도록 설계 → 싱클톤 패턴
        
    - 싱글톤 패턴
        - 정의 : 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
        - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하게!
        - 방법
            1. **static 영역에 객체 instance를 미리 하나 생성**해서 올려둔다.
                1. ex) private static final SingletonService *instance*  = new SingletonService();
            2. 이 객체 **인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회**할 수 있다. 이 메서드를 호
            출하면 항상 같은 인스턴스를 반환한다.
                1. ex) public static SingletonService getInstance() {
                    
                            return *instance*;
                    
                    }
                    
            3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 **private으로 막아서** 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.
                1. ex) private SingletonService(){}
    - 싱글톤 컨테이너(스프링 컨테이너)
        
        스프링 컨테이너 : 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리
        
        ![Untitled](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20-%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20e5abdff70dab4586b03daf02a34b7050/Untitled%208.png)
        
    - 싱글톤 방식의 주의점
        
        싱글톤 객체는 상태를 유지하게 설계하면 안된다!
        
        **※**사용자A 1만원 주문하고 사용자B 2만원 주문하면 사용자A 주문가격이 2만원으로?!!! 되는 문제 
        
        ****∴**** price 필드는 공유되는 필드인데 특정 클라이언트가 값을 변경한다 → 스프링은 항상 무상태로 설계
        
    - @Configuration과 싱글톤
    - @Configuration과 바이트코드 조작의 마법
    

- **섹션 6. 컴포넌트 스캔**
    
    @Bean 으로 등록한 클래스 X
    
    생성자에 @Autowired 붙여주면 의존관계 주입해줌
    

- **섹션 7. 의존관계 자동 주입**
    - 의존관계 주입의 4가지 방법
        - 생성자 주입
        - 수정자 주입(setter 주입)
        - 필드 주입
        - 일반 메서드 주입
        
        - 생성자 호출
            - 생성자 호출시점에 딱 1번 호출되는 것 보장
            - 불변. 필수 의존관계에 사용
            - 생성자가 1개면 Autowired 생략 가능
        - 수정자 주입
            
            선택적, 변경가능성 있는 의존관계 있을 시 사용
            
        - 필드주입
            
            값 변경 불가 / setter 만들어야
            
    - **Q. 생성자 주입의 장점**
        1. 불변 : 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다
        2. 누락 : 생성자 주입을 사용하면 다음처럼 주입 데이터를 누락 했을 때 컴파일 오류가 발생
        3. final 키워드 사용가능 : final 키워드를 통해 생성자에서 혹시라도 값이 설정되지 않는 오
        류를 컴파일 시점에 막아줌
        4. 프레임워크에 의존하지 않고 순수한 자바언어의 특징을 잘 살리는 방법임 !
    - 롬북과 최신 트렌드
        1. Getter, Setter, ToString  자동생성
        2. @RequiredArgsConstructor : final이 붙은 필수값을 가지고 생성자를 만들어줌
    - 조회 빈이 2개 이상 - 문제
        1. ＠Autowired 필드명 매칭
        2. @Qualifier (추가 구분자를 붙여주는 방법) : @Qualifier 끼리 매칭 → 빈 이름 매칭
        3. @Primary 사용 : 우선순위 지정
        4. Qualifier > Primary 우선순
    - 애노테이션 직접 만들기
    - 조회한 빈이 모두 필요할 때, List, Map
        
        
    - 자동, 수동의 올바른 실무 운영 기준
        
        
    

- **섹션 8. 빈 생명주기 콜백**
    - 빈 생명주기 콜백 시작
        - 플리케이션 시작 시점에 필요한 연결을 미리 해두고, 종료 시점에 연결을 모두 진행 ← 객체 초기와, 종료 작업 필요
        - **스프링 빈의 이벤트 라이프사이클**
        스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 사용 → 소멸전 콜백 → 스프링 종료
    - 애노테이션 @PostConstruct, @PreDestroy
        - 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod

- **섹션 9. 빈 스코프**
    - 프로토타입 스코프
        - 싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈 반환
        - 프로토타입 스코프는 항상 새로운 인스턴스를 생성해서 반환
        - **스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리**
        
    - 프로토타입 스코프 - 싱글톤 함께 사용시 문제점
        - 싱글톤 빈이 프로토타입 빈 사용 → 싱글톤 빈은 생성시점에만 의존관게 주입 → 프로토타입 빈이 새로 생성되기는 하지만 싱글톤 빈과 함계 계속 유지되는 문제
        
    - 프로토타입 스코프 - 싱글톤과 함께 사용시 Provider로 문제 해결
        - ObjectProvider : 스프링에 의존하는 문제
        - provider.get()을 통해 항상 새로운 프로토타입 빈 생성
        
    - 웹 스코프
        - 웹 환경에서만, 스프링이 해당 스코프 종료시점까지 관리(종료 메서드 호출)
        - 웹 스코프 종류
            - request : HTTP 요청 하나가 들어오고 나갈 때까지 유지 / 각 요청마다 별도의 빈 인스턴스 생성, 관리
            - session : HTTP Session과 동일한 생명주기를 가지는 스코프
            - application : 서블릿 컨텍스트와 동일한 생명주기
            - websocket : 웹 소켓과 동일한 생명주기
            
        
    - 스코프와 프록
        - **proxyMode = copedProxyMode.*TARGET_CLASS*** : 가짜 프록시 클래스를 만들어두고 HTTP request와 상관없이 가짜 프록시 클래스를 다른 빈에 미리 주

**※ 클라이언트 코드에서 “인터페이스 = new 구현 클래스”를 통해 하면 생기는 문제점? :** 구체 클래스를 변경할 때 클라이언트 코드도 함께 변경 → DIP 위반(인터페이스에만 의존해야되는데 구현 클래스에도 의존하기 때문) & OCP 위반

- DIP란?
    - DIP (Dependency inversion principle / 의존관계 역전 원칙) : 인터페이스에 의존, 구현 클래스 의존 X

**※ 위 문제를 해결하기 위한 해결방안? :** 인터페이스에만 의존할 수 있게 위부에서 생성자를 통해 구현 객체를 주입 ex) AppConfig