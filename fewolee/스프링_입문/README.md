# 스프링 입문- ****코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술****

---

### 정적 콘텐츠

- resources/static 폴더 안에 html 파일을 넣으면 정적 페이지 출력
- 웹 브라우저에서 [http://localhost:8080/hello-static.html](http://localhost:9090/hello-static.html) 를 넣으면 톰캣 서버에서 스프링으로 요청을 넘긴다. hello-static 이 매핑된 컨트롤러가 있는지 찾고 없으면 resources의 static(정적)폴더 내부에 hello-static이 있는지 찾고 웹 브라우저로 응답한다. controller에 hello-static.html mapping이 있으면 해당 요청을 우선적으로 처리하여 resources 내부 hello-static.html 파일은 렌더링되지 않음.

### MVC와 템플릿 엔진

- **MVC** : model, view, controller
    - 과거에는 jsp에 모조리 때려박는 방식으로 controller와 view를 같이 쓰는 MVC1방식 사용

웹 브라우저에서 [http://localhost:8080/hello-static.html](http://localhost:9090/hello-static.html)으로 들어가면 톰캣 서버에서 스프링으로 요청을 넘긴 후 컨트롤러에서 hello-static이 있는지 찾고 mapping되어 있으면 리턴값과 모델의 key와value 값을 스프링으로 넘겨줌.

스프링은 viewResolver가 동작하여 return값과 같은 이름을 찾아서 thymeleaf 템플릿 엔진에 넣으면 렌더링을 해서 변환이 된 html을 브라우저에 반환함

### API 방식

- **@ResponseBody =** HTTP의 BODY에 문자 내용을 직접 반환
    - @ResponseBody를 사용하면 ViewResolver를 사용하지 않음

- 웹 브라우저에서 [http://localhost:8080/hello-api.html](http://localhost:9090/hello-api.html) 으로 들어가면 톰캣 서버에서 스프링으로 요청을 넘김, 컨트롤러에서 hello-api가 있는지 찾고 @responsbody 어노테이션이 붙어있으면 Http Body에 문자내용을 직접 반환함.
- httpMessageConverter가 동작함. 단순 문자면 StringConverter가 동작하고 객체라면 jasonConverter가 동작하여 json방식으로 변환하여 응답
- 스프링은 default jackson 라이브러리를 사용하여 변환함
- Http Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합하여 HttpMessageConverter가 선택됨

### 회원 관리 예제 - 비즈니스 요구사항 정리

- **컨트롤러** : 웹 MVC의 컨트롤러 역할
- **서비스** : 핵심 비즈니스 로직 구현
- **리포지토리** : 데이터 베이스에 접근, 도메인 객체를 DB에 저장하고 관리
- **도메인** : 비즈니스 도메인 객체/ DB에 저장되고 관리될 정보들

### 스프링 빈을 등록하는 방법

**컴포넌트 스캔과 자동 의존관계 설정**

- 컴포넌트 스캔이 @Component라는 어노테이션을 찾아 해당 클래스의 인스턴스를 만들어 스프링 bean으로 등록
- @controller, @service, @repository 모두 컴포넌트를 사용한 어노테이션으로 스프링 빈으로 자동 등록된다
- 생성자에 @Autowired를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입 생성자가 1개만 있으면 생략가능
- 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때 기본적으로 싱글톤으로 등록함(유일하게 하나) 따라서 같은 스프링 빈이면 모두 같은 인스턴스임. 특별한 경우가 아니라면 싱글톤을 사용

**자바 코드로 직접 스프링 빈 등록하기**

- 클래스에 @Configuration을 사용하고 @Bean 어노테이션으로 작성하여 빈에 직접 등록할 수 있음. xml방식도 있지만 최근에는 사용하지 않는다

**DI 방식**

- 생성자주입 -> 의존관계가 실행중에 동적으로 변하는 경우(runtime 이후 변경되는 경우)는 거의 없으므로 생성자 주입을 권장.
- 필드주입 -> 필드주입의 경우 생성된 객체를 바꿀수 있는방법이 없으므로 추천되지 않는 방법
- setter주입 -> 객체를 생성했을때 set메소드 자체가 퍼블릭하게 노출이되어있기 때문에 값이 변경될 수 있음 한번세팅이 되고나면 바꿀 일이 잘 없음
- 정형화 된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔 사용한다.
- 정형화 되지 않거나 상황에 따라 구현 클래스를 변경해야하면 설정파일의 수정을 통해 스프링빈으로 등록한다. 직접 스프링빈을 등록하는 경우 이렇게 설정만 조금 수정해주면 변경을 쉽게 할 수 있다.

### 스프링의 장점

- 스프링의 DI (Dependencies Injection)을 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경할 수 있다.
- 기능을 완전히 변경해도 조립하는코드만 수정하고 실제 어플리케이션 수행에 필요한 코드를 하나도 변경하지 않고도 변경가능하다. 이게 OCP 개방폐쇄원칙을 지킨것
- 기능확장에는 열려있고, 실제코드의 수정이나 변경에는 닫혀있다.

### 스프링 통합 테스트

@SpringBootTest : 스프링 컨테이너와 테스트를 함께 실행한다.

@Transactional : 테스트 케이스에 이 어노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지않는다. test에 @Commit 어노테이션 사용하면 커밋 해 버림

### 스프링 JdbcTemplate

- JdbcTemplate을 사용하면 jdbc 코드를 현저히 줄일 수 있음
- Template Method 디자인 패턴으로 코드를 줄인 라이브러리
- 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다. 하지만 SQL은 직접 작성해 줘야 함

### JPA

- jpa는 기존 반복코드는 물론이고 기본적인 sql도 jpa가 직접 만들어 실행해줌
- sql과 객체중심 설계에서 객체중심 설계로 패러다임 전환을 할 수 있다.
- 개발 생산성을 높일 수 있음
- jpa는 표준 인터페이스고 구현은 각 기업에서 한다. 주로 hibernate를 사용한다

### 스프링 데이터 JPA

- 스프링 부트와 jpa만 사용하더라도 개발 생산성이 굉장히 증가한다
- 스프링 데이터 JPA를 사용하면 리포지토리에 구현 클래스 없이 인터페이스 만으로 개발을 완료할 수 있다
- 기본 crud기능도 스프링 데이터 jpa가 모두 제공한다

### AOP

- AOP는 공통적으로 사용해야하는 공통 관심 사항 코드가 많을때 묶어서 사용하기위해 사용한다.
- 공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern) 분리
- 공통 관심 사항 : 인프라 로직(실행 시간을 측정한다던지 등등)
- 핵심 관심 사항 : 비즈니스 로직(주 업무로직; 회원가입 조회 등등) ,핵심관심사항을 깔끔하게 유지할 수 있음
- aop적용 전에는 컨트롤러에서 서비스를 의존하고있으니 서비스의 메소드를 호출함
- aop를 적용하면 스프링컨테이너는 빈을 등록할 때 프록시를 이용해 가짜 memberService를 먼저 만들어 호출하게됨
- 가짜 스프링빈이 끝나면 joinpoint.proceed()를 통해 진짜 메소드가 호출된다.